[TOC]

# Git

## 0. Git基础

**使用Git的一些特点**

>   1.  直接记录快照，而非差异比较
>   2.  近乎所有操作都是本地执行
>   3.  时刻保持数据完整性
>   4.  多数操作仅添加数据



-   `git status `：查看当前 git 的信息
-   `git add .`：把当前目录添加到暂存区
-   `git add <filename>`：添加到暂存区（.git/index）
-   `git commit -m "信息"`：添加到版本库（.git）
-   `git push`：提交到远程
-   `git log`：查看日志
-   `git reset [gitid]`：退回到哪个状态
-   `git show [gitid]`：展示git操作
-   `ssh-keygen -t rsa -b 4096 -C "your_email@example.com"`：生成 ssh
-   `clip < ~/.ssh/id_rsa.pub`：将ssh内容复制到剪切板上
-   `git clone ssh值`：下载到本地
-   `git pull`：拉一下远程
-   `git checkout mastere`：切换到主分支 
-   `git branch branch1`：创建分支branch1
-   `git checkout branch1`：切换到分支branch1
-   `git checkout -b branch1`：创建并且切换到branch1分支
-   `git push --set-upstream origin branch2`：在远程建立branch2分支
-   `git push -u origin master`：



## 1. 文件的三种状态



对于任何一个文件，在git内都只有三种状态

1.  `已提交（commited）`：表示该文件已经被安全的存放到本地版本库中。
2.  `已修改（modified）`：表示修改了某个文件，但还没有提交保存，换句话说，此文件在本地工作目录已修改，但是没有放到暂存区中。
3.  `已暂存（staged）`：把已修改的文件放在下次提交的时要保存的清单中，换句话说，就是此文件在暂存区中。

>   1.  如果git目录中保存着特定版本的文件，就属于已提交状态。
>
>   2.  如果做了修改并已放到暂存区域，就属于已暂存状态
>   3.  如果自上次取出后，做了修改但还没有放到暂存区域，就属于已修改状态

>   每个项目都有一个git目录
>
>   *   如果使用`git clone`，就是其中的`.git`目录
>
>   *   如果使用`git clone --bare`，新建的目录本身就是`git`目录
>
>   该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据

下图展示了工作区、暂存区和版本库之间的关系



![](https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg)



## 2. Git工作流程

1.  在工作目录中修改某些文件
2.  对修改后的文件进行快照，然后保存到暂存区域
3.  提交更新，将暂存区中的文件保存到版本库





## 3. 删除文件

>   使用 `git rm 文件名`命令，就是从已跟踪文件清单中移除，也就是从暂存区中移除。
>
>   使用前提：此文件已经在暂存区域中存在。
>
>   如果只是简单从工作目录中删除文件，直接 `rm filename`即可，不用 git命令
>
>   Changed but not updated：修改了，但没有添加到暂存区

-   `git rm --cached filename`：仅仅删除暂存区里的文件
-   `git rm -f filename`：删除暂存区和工作区的文件（此文件已经在暂存区且删除之前内容在工作空间修改过）
-   `git rm filename`：删除暂存区和工作区的文件



## 4. 版本回退



>   如果不仅添加到了暂存区，而且提交到了版本库，这个时候不能用 `git rm 文件名` 命令
>
>   需要使用 `git reset 版本库ID`
>
>   git reset 有三个选项：



1.  `git reset -- soft 版本库ID`：撤销已经提交的版本库，不会修改暂存区和工作区
2.  `git reset -- mixed 版本库ID`：撤销已经提交的版本库和暂存区，不会修改工作区
3.  `git reset -- hard 版本库ID`：彻底将工作区、暂存区、版本库恢复到指定的版本库



## 5. 查看已暂存和未暂存的更新

1.  `git diff`：比较当前文件在工作目录中和在暂存区域快照之间的差异

>   将 a.txt 文件添加到暂存区，然后修改它，但是别暂存，运行`git status`命令才会有内容
>
>   ==注==：
>
>   1.  如果文件没有加入到暂存区域，单单运行`git diff`是什么也没有的
>   2.  如果一下暂存了所有更新过的文件，例：`git add .`，运行`git diff`也是什么也没有的
>   3.  红色文字代表从当前开始是追加的，绿色文字代表是新添加的，白色代表是原始数据。

2.  `git diff --cached`：比较暂存起来的文件和上次提交的文件之间快照的差异

>   ==注==：git 1.6.1及更高版本还允许使用 `git diff --staged`，效果时相同的
>
>   当你修改文件时，需要再次执行`git add <filename>`命令，添加到暂存区，才能进行比较



## 6. 忽略某些文件

>   一般我们总会有些文件无需纳入git的管理，也不希望它们总出现在未跟踪的文件列表中，通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。
>
>   我们可以创建一个名为`.gitignore`的文件，列出要忽略的文件模式

例如：

```
# 此为注释 – 将被 Git 忽略
*.a       # 忽略所有 .a 结尾的文件
!lib.a    # 但 lib.a 除外
```

## 7. 跳过使用暂存区域

>   要使用跳过暂存区域，是在所有文件已经被跟踪过的基础上
>
>   不用再次使用`git add .`（将所有的文件再次添加到暂存区，在提交到版本库中），而是直接提交到版本库，一步到位。

## 8. 对文件的重命名

*   `git mv file_src file_dist`：将原文件名修改为目标文件名



## 9. 查看提交历史

>   每次更新都有一个SHA-1校验、作者的名字、电子邮箱地址、提交时间以及提交说明（注释）

1.  `git log`默认带参数，会按时间列出所有的更新，最新的排在上面。
2.  `git log -p`：显示每次提交的内容差异
3.  `git log -n`：显示最近的n次更新



## 10. 远程仓库的使用

### 1. 查看当前的远程仓库

1.  `git remote`：查看当前配置有哪些远程仓库，它会列出每个仓库的简短名字。

>   在clone完某个仓库后，至少可以看到一个名为 `origin`的远程仓库，`git`默认使用这个名字来标识你所克隆的原始仓库

2.  `git remote -v`：显示远程仓库和对应的克隆地址

>   v即为 verbose（冗长的）的简写
>
>   如果有多个远程仓库，此命令将全部列出

### 2. 添加远程仓库

1.  `git remote add [shortname] [url]`：添加一个远程仓库并指定一个简单的名字（方便来引用）。

### 3. 从远程仓库抓取数据

1.  `git fetch [remote_name]`：从远程仓库中拉取本地没有的数据到本地。

>   ==注==：
>
>   1.  `fetch`命令只是将远端的数据拉动本地仓库，并不自动合并到当前工作分支，需要手动合并。
>   2.  如果是`clone`一个仓库，此命令会自动将远程仓库归于`origin`仓库下，`git fetch origin`：会抓取自你上次克隆别人仓库以来，别人对这个仓库的所有更新文件。

>   ==注==：
>
>   1.  如果设置了某个分支用于跟踪某个远端仓库的分支，可以使用 `git pull` 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。
>   2.  实际上，默认情况下`git clone` 命令本质上就是自动创建了本地的 `master` 分支用于跟踪远程仓库中的 `master` 分支（假设远程仓库确实有 `master` 分支）。
>   3.  一般我们运行`git pull`，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。

### 4. 推送数据到远程仓库

>   项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库的数据推送到远程仓库。
>
>   必须保证本地仓库里面有提交，注意是本地仓库而不是暂存区

1.  `git push [remote_name] [branch_name]`：把本地的`master`分支推送到`origin`服务器上

>   ==注==：
>
>   1.  克隆操作会自动使用默认的`master`和`origin`名字
>   2.  只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。
>   3.  如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。

### 5. 查看远程仓库的信息

1.  `git remote show [remote_name]`：查看某个远程仓库的详细信息。

>   查看克隆仓库的信息：`git remote show origin`

### 6. 远程仓库的删除和重命名

>   在新版git中可以使用`git remote rename`命令修改某个远程仓库在本地的简短名称

1.  `git remote rename [src_name] [dist_name]`：给远程仓库重命名

>   ==注==：对远程仓库的重命名，也会使对应的分支名称发生变化

2.  `git remote rm [remote_name]`：移除对应的远程仓库



## 11. 检查当前文件状态

>   要确定哪些文件当前处于什么状态，可以用`git status`命令
>
>   刚把仓库克隆完,工作目录相当干净，换句话说，当前没有任何跟踪着的文件，也没有任何文件在上次提交后更改过。
>
>   在`Untracked files`这行下面。git不会自动将之纳入跟踪范围，除非你明明白白地告诉它："我需要跟踪该文件"，因而不用担心把临时文件什么的也纳入版本管理。

​	

## 12. 跟踪新文件

>   *   使用命令`git add`开始跟踪一个新文件
>
>   *   在`Changes to be committed`这行下面，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。
>
>   *   在`git add`后面可以指明要跟踪的文件或目录路径
>
>   *   如果是目录的话，就说明要递归该目录下的所有文件。
>
>   >   其实 `git add`的潜台词就是把目标文件的快照放入暂存区，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪

## 13. 暂存已修改的文件

>   在`Changed but not updated`这行下面，说明已跟踪的文件内容发生了变化，但还没有放到暂存区。
>
>   要暂存这次更新，需要运行`git add`命令（这是个多功能命令，根据目标文件的状态不同，此命令的效果不同）
>
>   1.  可以用来跟踪新文件
>   2.  把修改过的已跟踪的文件放到暂存区
>   3.  用于合并时把有冲突的文件标记为已解决状态